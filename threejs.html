<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Two Cubes</title>

<style>
    body {
        margin: 0;
        display: flex;
        height: 100vh;
        background: white;
    }

    .area {
        flex: 1;
        border: 3px solid rgb(255, 255, 255);
        position: relative;
        height: 100%;
        overflow: hidden;
    }

    .title {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 24px;
        font-weight: bold;
        color: rgba(166, 85, 185, 0.5);
        z-index: 10;
        pointer-events: none;
    }

    .info-box {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(166, 85, 185, 0.5);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    line-height: 1.4;
    pointer-events: none; /* so cube still receives clicks */
    z-index: 20;
    }

</style>
</head>

<body>
    <div class="area" id="area1">
        <div class="title">Area 1 – Cube 1</div>

        <div class="info-box">
            <b>Controls:</b><br>
            Left click: rotate<br>
            Right click: move<br>
            Mouse wheel: zoom
        </div>
    </div>

    <div class="area" id="area2">
        <div class="title">Area 2 – Cube 2</div>

        <div class="info-box">
            <b>Controls:</b><br>
            Left click: rotate<br>
            Right click: change color
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --------------------------------------------------
        // AREA 1 (unchanged)
        // --------------------------------------------------
        function createScene(container) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.z = 3;

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);

            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshNormalMaterial();
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener("resize", () => {
                renderer.setSize(container.clientWidth, container.clientHeight);
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
            });
        }

        createScene(document.getElementById("area1"));


        // --------------------------------------------------
        // AREA 2 — custom: right click = color change,
        // left click = rotate, no zoom, no pan
        // --------------------------------------------------
        function createColorChangingScene(container) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.z = 3;

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Orbit controls: allow left-button rotation only
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false; // disable zoom
            controls.enablePan = false;  // disable right-click pan
            controls.mouseButtons.RIGHT = THREE.MOUSE.PAN; // neutralize right click

            // Cube
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            // FIX: Remove black faces by adding ambient light
            const ambient = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambient);

            const directional = new THREE.DirectionalLight(0xffffff, 0.6);
            directional.position.set(3, 3, 3);
            scene.add(directional);

            // Colors to cycle through
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
            let colorIndex = 0;

            // Raycaster for detecting right-click on cube
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            // Prevent context menu so right click works
            renderer.domElement.addEventListener("contextmenu", e => e.preventDefault());

            // Right click to change color
            renderer.domElement.addEventListener("mousedown", (event) => {
                if (event.button !== 2) return; // only right-click

                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const hit = raycaster.intersectObject(cube);

                if (hit.length > 0) {
                    colorIndex = (colorIndex + 1) % colors.length;
                    cube.material.color.set(colors[colorIndex]);
                }
            });

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener("resize", () => {
                renderer.setSize(container.clientWidth, container.clientHeight);
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
            });
        }

        createColorChangingScene(document.getElementById("area2"));
    </script>
</body>
</html>
